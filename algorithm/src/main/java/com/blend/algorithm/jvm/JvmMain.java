package com.blend.algorithm.jvm;

/**
 * 历史：HotSpot，热点代码探测技术，即时编译器（发现最有价值的代码，如果代码用得非常多，就会把这些代码编译成本地代码）。
 * JIT(JUST IN TIME)：为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优
 * 化。优化包括内联和逃逸分析（方法逃逸和线程逃逸）。
 * 机器码和本地代码是可以直接识别运行的代码，也就是机器指令。但是字节码是不能直接运行的，需要经过JVM解释成机器指令才能运行。
 * 热点代码：被多次调用的方法，或者被多次执行的方法体，在运行时会被翻译成机器码。
 * <p>
 * 运行时数据区域：Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，也就是把class文件加载进内存之后：
 * 类型：程序计数器、虚拟机栈、本地方法栈、Java堆、方法区（运行时常量池）。直接内存
 * 1.程序计数器：指向当前线程正在执行的字节码指令的地址(行号)。各线程之间独立存储，互不影响。
 * 原因是：Java是多线程的，意味着线程切换确保多线程情况下的程序正常执行。
 * 2.虚拟机栈：每个线程私有的，线程在运行时，在执行每个方法的时候都会打包成一个栈帧，存储了局部变量表，操作数栈，动态链接，方法出口
 * 等信息，然后放入栈。每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。
 * 栈的大小缺省为1M，可用参数–Xss调整大小，例如-Xss256k
 * 1)局部变量表:顾名思义就是局部变量的表，用于存放我们的局部变量的。首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，
 * 一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的Object对象，我们只需要存放
 * 它的一个引用地址即可。
 * 2)操作数栈:存放我们方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据
 * 类型，所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的，操作数栈运行方法是会一直运行入栈/出栈的操作。
 * 3)动态连接:Java语言特性多态（需要类加载、运行时才能确定具体的方法），动态特性（Groovy、JS、动态代理）
 * 4)返回地址:正常返回（调用程序计数器中的地址作为返回）、异常的话（通过异常处理器表<非栈帧中的>来确定）
 * 3.本地方法栈:保存的是native方法的信息。当一个JVM创建的线程调用native方法后，JVM不再为其在虚拟机栈中创建栈帧，JVM只是简单地动态
 * 链接并直接调用native方法。但是虚拟机规范无强制限定，各虚拟机自由实现，HotSpot直接把本地方法栈和虚拟机栈合二为一。
 * 4.Java堆。几乎所有的对象实例，数组。
 * 5.方法区。类信息，常量，静态变量，即时编译期编译后的代码(也就是对热点代码进行的编译，JVM会把这些代码编译成与本地平台相关的机器码，
 * 并进行各种层次的优化)。在JDK1.8之后没有方法区，取而代之的是元空间。同样，这也会影响垃圾回收算法。
 * 6.直接内存。不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。这块内存不受java堆大小限制，但受本机总内存的限制，
 * 可以通过MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM异常。
 * <p>
 * 站在线程的角度来看：
 * 线程私有区域：程序计数器，虚拟机栈，本地方法栈。(随着线程的产生和消亡，因此不需要过多考虑内存回收问题，在编译时确定所需内存大小)
 * 线程共享区域：堆，方法区。
 * <p>
 * 栈和堆的区别：
 * 功能：以栈帧的方式存储方法调用的过程，并存储方法调用过程中基本数据类型的变量以及对象的引用变量，其内存分配在栈上，变量出了作用域就会自动释放；
 * 而堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。
 * 线程独享还是共享：栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。
 * 堆内存中的对象对所有线程可见，堆内存中的对象可以被所有线程访问。
 * 空间大小：栈的内存要远远小于堆内存。
 * <p>
 * java.lang.StackOverflowError：一般的方法调用是很难出现的，如果出现了要考虑是否有无限递归。
 * 虚拟机栈带给我们的启示：方法的执行因为要打包成栈桢，所以天生要比实现同样功能的循环慢，所以树的遍历算法中：递归和非递归(循环来实现)都有存在的
 * 意义。递归代码简洁，非递归代码复杂但是速度较快。
 * <p>
 * 对象的分配过程：虚拟机遇到一条new指令时。
 * 1.检查加载
 * 先执行相应的类加载过程。
 * 2.分配内存
 * 1)指针碰撞
 * 接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。如果Java堆中内存是绝对规整的，所有用过
 * 的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等
 * 的距离，这种分配方式称为“指针碰撞”。
 * 2)空闲列表
 * 如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存
 * 块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。
 * 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
 * 并发安全:除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情
 * 况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。
 * 解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存分配
 * 的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），
 * 如果设置了虚拟机参数 -XX:UseTLAB，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，
 * 如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继
 * 续使用。
 * TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。
 * TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满
 * （分配指针top撞上分配极限end了），就新申请一个TLAB。
 * 3.内存空间初始化（注意不是构造方法）
 * 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码
 * 中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
 * 4）设置
 * 接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息
 * 存放在对象的对象头之中。
 * 5）对象初始化
 * 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，
 * 一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。
 * <p>
 * 对象的内存布局：
 * 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
 * 对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间
 * 戳等。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。第三部分对齐填充并不是必然存
 * 在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对对象的大小必须是8字节的整数倍。当对象其他数据部分没有
 * 对齐时，就需要通过对齐填充来补全。
 * <p>
 * 对象的访问定位
 * 建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种。
 * 1.句柄。如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据
 * 与类型数据各自的具体地址信息。
 * 2.直接指针。如果使用直接指针访问， reference中存储的直接就是对象地址。
 * 这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）
 * 时只会改变句柄中的实例数据指针，而reference本身不需要修改。
 * 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常
 * 可观的执行成本。
 * 对Sun HotSpot而言，它是使用直接指针访问方式进行对象访问的。
 * <p>
 * 逃逸分析：虚拟机提供的一种优化技术，基本思想是，对于线程私有的对象，将它分配在栈上，而不分配在堆上。好处是对象跟着方法调用自行销毁，不需要
 * 进行垃圾回收，可以提高性能。
 * 栈上分配需要的技术基础，逃逸分析。逃逸分析的目的是判断对象的作用域是否会逃逸出方法体。注意，任何可以在多个线程之间共享的对象，一定都属于逃逸
 * 对象。
 * 这也解析了为什么前面说绝大部分对象都是在堆中分配的，因为有一部分对象是在因为逃逸分析在栈上分配的。
 * 逃逸分析（Escape Analysis）是判断一个对象是否被外部方法引用或外部线程访问的分析技术，编译器会根据逃逸分析的结果对代码进行优化。
 * 根据逃逸分析的结果，进行优化的手段主要有三种：栈上分配、锁消除、标量替换。
 */
class JvmMain {

    //在这里会禁止指令重排
    final String a;

    public JvmMain() {
        a = "a";
    }

    private static class User {
        public int id = 0;
        public String name = "";
    }

    //同样的User的对象实例，分配100000000次，启用栈上分配，只需4ms，不启用，需要900多ms，这就是使用逃逸分析的好出。
    public static void alloc() {
        User u = new User();  //Object  在堆上分配的() ,有逃逸分析的技术 ，在栈中分配的
        u.id = 5;
        u.name = "King";
    }

    public static void main(String[] args) {
        long b = System.currentTimeMillis(); //开始时间
        for (int i = 0; i < 100000000; i++) {//一个方法运行1亿次（）
            alloc();
        }
        long e = System.currentTimeMillis(); //结束时间
        System.out.println(e - b);//打印运行时间：毫秒
    }
}
