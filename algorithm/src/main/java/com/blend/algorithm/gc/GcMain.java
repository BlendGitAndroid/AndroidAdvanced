package com.blend.algorithm.gc;

/**
 * 栈：栈中的生命周期是跟随线程，所以一般不需要关注。
 * 堆：堆中的对象是垃圾回收的重点。
 * 方法区/元空间：这一块也会发生垃圾回收，不过这块的效率比较低，一般不是我们关注的重点。
 * <p>
 * 判断对象的存活
 * 1.引用计数法：快、方便、实现简单，缺点：对象互相引用时，很难判断对象是否被回收。(PHP语言在使用)
 * 2.可达性分析法：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，
 * 当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
 * <p>
 * GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,
 * 被GC roots引用的对象不被GC回收，由于成员变量是属于是一个实例的，是分配在堆上的，所以不能作为GC roots。作为GC Roots的对象包括下面几种：
 * 1)虚拟机栈（栈帧中的本地变量表）中引用的对象。虚拟机栈中的引用的对象可以作为GC Root。我们程序在虚拟机的栈中执行，每次函数调用调用都是
 * 一次入栈。在栈中包括局部变量表和操作数栈，局部变量表中的变量可能为引用类型(reference)，他们引用的对象即可作为GC Root。不过随着函数
 * 调用结束出栈，这些引用便会消失。
 * 2)方法区中类静态属性引用的对象。
 * 3)方法区中常量引用的对象。
 * 4)本地方法栈中JNI（即一般说的Native方法）引用的对象。
 * <p>
 * 四种引用类型：
 * 1.强引用。
 * 2.软引用。一些有用但是并非必需，用软引用关联的对象，系统将要发生OOM之前，这些对象就会被回收。
 * 3.弱引用。一些有用（程度比软引用更低）但是并非必需，用弱引用关联的对象，只能生存到下一次垃圾回收之前，GC发生时，不管内存够不够，都会被回收。
 * ThreadLocal中就有这个引用。
 * 4.虚引用。幽灵引用，最弱，被垃圾回收的时候收到一个通知。
 * 5.还有一种是终结器引用，需要重写finalize方法。
 * 终结器引用只有重写了finalize方法的才会使用，所以GC扫描还要分是否重写了finalize方法。并且finalize并不保证被正确执行，
 * 在java9中被废弃，所以一般不用。java对象在创建的时候会判断是否有重写了finalize方法，如果重写了则他这个对象加入到FinalizerThread的引
 * 用队列中，当第一次执行垃圾回收时，若这个对象能被回收，首先通过引用队列找到这个对象并执行finalize方法，之后把该对象从FinalizerThread的引用队
 * 列中移除。当第二次执行GC，因为没有被任何引用持有，该对象就会被回收。
 * <p>
 * 垃圾回收算法：
 * 1.复制算法。将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把
 * 已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要按顺序分配内存即可，实现
 * 简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半。
 * 注意：内存移动是必须实打实的移动（复制），不能使用指针玩。
 * 专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor
 * 空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden
 * 和刚才用过的Survivor空间。
 * HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。
 * 当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）
 * 进行分配担保（Handle Promotion）
 * 2.标记-清除算法。算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它的主要不足空间问题，标记
 * 清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃
 * 圾收集动作。
 * 3.标记-整理算法。首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端
 * 边界以外的内存。
 * <p>
 * 堆内存分配策略：
 * 新生代：Eden空间，From Survivor，To Survivor。默认比例为8:1:1。进行的是Minor GC。
 * 老年代：进行的是Full GC。
 * 永久代：方法区是JVM规范概念，而永久代则是Hotspot虚拟机对这个概念的实现。
 * java8以后，HotSpots取消了永久代。取而代之的是元空间。
 * 1.对象优先在Eden分配，如果说Eden内存空间不足，就会发生Minor GC。
 * 2.大对象直接进入老年代，大对象：需要大量连续内存空间的Java对象，比如很长的字符串和大型数组。
 * 1)导致内存没有空间，还是需要提前进行垃圾回收获取连续空间来放他们。
 * 2)会进行大量的内存复制。
 * 3.长期存活的对象将进入老年代，默认15岁。
 * 4.动态对象年龄判定，为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold
 * 才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直
 * 接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。
 * 5.空间分配担保：新生代中有大量的对象存活，survivor空间不够，当出现大量对象在MinorGC后仍然存活的情况（最极端的情况就是内存
 * 回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代.只要老年代的连续空间大于新
 * 生代对象的总大小或者历次晋升的平均大小，就进行Minor GC，否则FullGC。
 * <p>
 * 垃圾回收算法：在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本
 * 就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。
 * <p>
 * 分代收集策略：区分单线程和多线程。
 * Serial/Serial Old：最古老的，单线程，独占式，成熟，适合单CPU服务器。
 * ParNew：和Serial基本没区别，唯一的区别：多线程，多CPU的，停顿时间比Serial少。
 * CMS：是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重
 * 视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。从名字（包含“Mark Sweep”）
 * 上就可以看出，CMS收集器是基于“标记—清除”算法实现的。
 * G1垃圾回收器：JDK7以后就是G1垃圾回收器。
 * <p>
 * Stop The World现象
 * GC收集器和我们GC调优的目标就是尽可能的减少STW的时间和次数。GC线程收集和回收也是消耗时间的。
 * <p>
 * 额外知识点：
 * 1M的数组大约占据 1.5M的空间(对象头，对象数据、填充)，因为对象头和填充数据会占用空间。
 * <p>
 * <p>
 * <p>
 * 方法区用于存储JVM加载的类信息（版本、字段、方法、接口）、常量、静态变量、即时编译器编译后的代码等数据。实际上在Java虚拟机的规范中方法
 * 区是堆中的一个逻辑部分，但是它却拥有一个叫做非堆(Non-Heap)的别名。对于方法区的实现，不同虚拟机中策略也不同。以我们常用的HotSpot虚拟机为例，
 * 其设计团队使用永久带来实现方法区，并把GC的分代收集扩展至永久带。这样设计的好处就是能够省去专门为方法区编写内存管理的代码。但是在实际的场景中，
 * 这样的实现并不是一个好的方式，因为永久带有MAX上限，所以这样做会更容易遇到内存溢出问题。
 * 关于方法区的GC回收，Java虚拟机规范并没有严格的限制。虚拟机在实现中可以自由选择是否实现垃圾回收。主要原因还是方法区内存回收的效果比较
 * 难以令人满意，方法区的内存回收主要是针对常量池(1.7已经将常量池逐步移出方法区)以及类的卸载，但是类型卸载在实际场景中的条件相当苛刻。
 * 另外还需要注意的是在HotSpot虚拟机中永久带和堆虽然相互隔离，但是他们的物理内存是连续的。而且老年代和永久带的垃圾收集器进行了捆绑，因此
 * 无论谁满了都会触发永久带和老年的GC。
 * 元空间在1.8中不在与堆是连续的物理内存，而是改为使用本地内存(Native memory)。元空间使用本地内存也就意味着只要本地内存足够，就不会出现
 * OOM的错误。默认情况下元空间大小是无限的。
 * 采用元空间而不用永久代的原因：
 * 1.为了解决永久代的OOM问题，运行时常量池中的元数据和class对象存放在永久代中，容易出现性能问题和内存溢出。
 * 2.类及方法的信息等比较难确定其大小，因此对于永久代大小指定比较困难，大小容易出现永久代溢出，太大容易导致老年代溢出（堆内存不变，此消彼长）。
 * 3.永久代会为GC带来不必要的复杂度，并且回收效率偏低。
 * <p>
 * 常量池：
 * jdk7之前常量池是存放在永久代（hotspot虚拟机对应方法区区的实现）中，方法区与堆是逻辑上是独立的，但是内存地址是连续的。
 * jdk7字符串常量池从永久代中移到了堆内存中，属于堆内存的一部分，但是运行时常量池和静态常量池还在永久代。
 * jdk8移除了永久代并由元空间（metaspace）代替，存放在本地内存（native space）中。运行时常量池和类文件常量池（静态常量池）存放在元空间中，
 * 而字符串常量池依然存放在堆中。
 * <p>
 * 常量池的分类：
 * 1.类文件常量池/静态常量池（静态常量池是编译期间创建和使用的）。class文件编译生成class字节码文件，其结构有一项是常量池，用于存放字面量和符号引用。
 * 这部分数据在类加载后会进入方法区的运行时常量池。存放的是编译器生成的字面量和符号引用，是在编译期间已经确定的。
 * 2.运行时常量池。JVM必须经过加载、连接、初始化，而连接又包括验证、准备、解析。在加载的时候，静态常量池的内容会加载到运行时常量池中，如果发现是
 * 成员字符串，字符串就会被装载到字符串常量池中，如果是局部字符串，则在执行到相关代码时才会用到字符串常量池。在解析阶段，会把静态常量池的符号引用
 * 转成直接引用，直接引用存储在运行时常量池。不同的类公用同一个运行时常量池。
 * 3.字符串常量池。字符串常量池中存放的是字符串的引用，真正的字符串还是在堆中创建的。当用字面量赋值的方法创建字符串时，无论创建多少次，只要字符串
 * 的值相同，它们所指向的都是堆中的同一个对象。
 */
class GcMain {

    // 下面演示的就是列表内存泄露的例子
    // 当不用的时候要手动置为null，防止内存泄露，ArrayList的remove就是这样的
    public static void main(String[] args) {
        // Stack stack = new Stack();  //new一个栈
        // Object o = new Object(); //new一个对象
        // System.out.println("o=" + o);
        // stack.push(o); //入栈
        // Object o1 = stack.pop(); //出栈
        // System.out.println("o1=" + o1);
        // System.out.println(stack.elements[0]); //打印栈中的数据

        stringTest();
    }


    private static void stringTest() {
        String s = new String("2");
        s.intern();
        String s2 = "2";
        System.out.println(s == s2);

        String s3 = new String("3") + new String("3");
        s3.intern();
        String s4 = "33";
        System.out.println(s3 == s4);

        // Java中基本类型的比较，是比较的值，而不是比较的地址，并且存储在栈中
        int aa = 128;
        int bb = 128;
    }

    private static class Stack {

        public Object[] elements;
        private int size = 0;
        private static final int Cap = 16;

        public Stack() {
            elements = new Object[Cap];
        }

        public void push(Object e) { //入栈
            elements[size] = e;
            size++;
        }

        public Object pop() {  //出栈
            size = size - 1;
            Object o = elements[size];
            elements[size] = null;  //让GC 回收掉
            return o;
        }
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
    }
}
